var searchIndex = {};
searchIndex["tk_http"] = {"doc":"This crate contains implementation of HTTP/1.0 and HTTP/1.1 with websockets support. (HTTP/2 support is planned)","items":[[4,"Version","tk_http","Enum reprsenting HTTP version.",null,null],[13,"Http10","","Version 1.0 of the HTTP protocol",0,null],[13,"Http11","","Version 1.1 of the HTTP protocol",0,null],[4,"Status","","Enum with some HTTP Status codes.",null,null],[13,"Continue","","",1,null],[13,"SwitchingProtocol","","",1,null],[13,"Ok","","",1,null],[13,"Created","","",1,null],[13,"Accepted","","",1,null],[13,"NonAuthoritativeInformation","","",1,null],[13,"NoContent","","",1,null],[13,"ResetContent","","",1,null],[13,"PartialContent","","",1,null],[13,"MultipleChoices","","",1,null],[13,"MovedPermanently","","",1,null],[13,"Found","","",1,null],[13,"SeeOther","","",1,null],[13,"NotModified","","",1,null],[13,"UseProxy","","",1,null],[13,"TemporaryRedirect","","",1,null],[13,"PermanentRedirect","","",1,null],[13,"BadRequest","","",1,null],[13,"Unauthorized","","",1,null],[13,"PaymentRequired","","",1,null],[13,"Forbidden","","",1,null],[13,"NotFound","","",1,null],[13,"MethodNotAllowed","","",1,null],[13,"NotAcceptable","","",1,null],[13,"ProxyAuthenticationRequired","","",1,null],[13,"RequestTimeout","","",1,null],[13,"Conflict","","",1,null],[13,"Gone","","",1,null],[13,"LengthRequired","","",1,null],[13,"PreconditionFailed","","",1,null],[13,"RequestEntityTooLarge","","",1,null],[13,"RequestURITooLong","","",1,null],[13,"UnsupportedMediaType","","",1,null],[13,"RequestRangeNotSatisfiable","","",1,null],[13,"ExpectationFailed","","",1,null],[13,"UpgradeRequired","","",1,null],[13,"TooManyRequests","","",1,null],[13,"InternalServerError","","",1,null],[13,"NotImplemented","","",1,null],[13,"BadGateway","","",1,null],[13,"ServiceUnavailable","","",1,null],[13,"GatewayTimeout","","",1,null],[13,"VersionNotSupported","","",1,null],[0,"server","","HTTP server protocol implementation",null,null],[3,"Error","tk_http::server","HTTP server error",null,null],[3,"Encoder","","This a response writer that you receive in `Codec`",null,null],[3,"EncoderDone","","This structure returned from `Encoder::done` and works as a continuation that should be returned from the future that writes request.",null,null],[3,"FutureRawBody","","A future that yields `RawBody` after buffer is empty",null,null],[3,"RawBody","","The actual raw body",null,null],[3,"Proto","","A low-level HTTP/1.x server protocol handler",null,null],[3,"Head","","A borrowed structure that represents request headers",null,null],[3,"HeaderIter","","Iterator over all meaningful headers for the request",null,null],[3,"WebsocketHandshake","","Contains all the imporant parts of a websocket handshake",null,null],[12,"accept","","The destination value of `Sec-WebSocket-Accept`",2,null],[12,"protocols","","List of `Sec-WebSocket-Protocol` tokens",2,null],[12,"extensions","","List of `Sec-WebSocket-Extensions` tokens",2,null],[3,"Config","","Fine-grained configuration of the HTTP server",null,null],[3,"RecvMode","","This type is returned from `headers_received` handler of either client client or server protocol handler",null,null],[4,"RequestTarget","","A middle part of the request line",null,null],[13,"Origin","","Usual form of `/hello?name=world`",3,null],[13,"Absolute","","Full url: `http://example.com:8080/hello`",3,null],[12,"scheme","tk_http::server::RequestTarget","Scheme, might be `http` or `https` (latter is useless for now)",3,null],[12,"authority","","Authority is basically `host[:port]`",3,null],[12,"path","","Path relative to root, it's not normalized, so might be empty",3,null],[13,"Authority","tk_http::server","Only hostname `example.com:8080`, only useful for `CONNECT` method",3,null],[13,"Asterisk","","Asterisk `*`",3,null],[11,"new","","Create a config with defaults",4,{"inputs":[],"output":{"name":"config"}}],[11,"inflight_request_limit","","A number of inflight requests until we stop reading more requests",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"inflight_request_prealoc","","Size of the queue that is preallocated for holding requests",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"done","","Create a Arc'd config clone to pass to the constructor",4,{"inputs":[{"name":"self"}],"output":{"name":"arc"}}],[11,"first_byte_timeout","","Timeout receiving very first byte over connection",4,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"keep_alive_timeout","","Timeout of idle connection (when no request has been sent yet)",4,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"headers_timeout","","Timeout of receiving whole request headers",4,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"input_body_byte_timeout","","Maximum delay between any two bytes of input request received",4,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"input_body_whole_timeout","","Timeout of whole request body received",4,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"output_body_byte_timeout","","Maximum delay between any two bytes of the output request could be sent",4,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"output_body_whole_timeout","","Timeout for the whole response body to be send to the client",4,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",5,{"inputs":[{"name":"errorenum"}],"output":{"name":"self"}}],[11,"description","","",5,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"custom","","Create an error instance wrapping custom error",5,{"inputs":[{"name":"e"}],"output":{"name":"error"}}],[11,"from","","",5,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"new","","Create a new protocol implementation from a TCP connection and a config",6,{"inputs":[{"name":"s"},{"name":"arc"},{"name":"d"},{"name":"handle"}],"output":{"name":"proto"}}],[11,"poll","","",6,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"write_file","","",7,{"inputs":[{"name":"self"},{"name":"sendfile"}],"output":{"name":"result"}}],[11,"poll_write","","",7,{"inputs":[{"name":"self"}],"output":{"name":"async"}}],[11,"response_continue","","Write a 100 (Continue) response.",8,{"inputs":[{"name":"self"}],"output":null}],[11,"status","","Write status line using `Status` enum",8,{"inputs":[{"name":"self"},{"name":"status"}],"output":null}],[11,"custom_status","","Write custom status line",8,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"str"}],"output":null}],[11,"add_header","","Add a header to the message.",8,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"format_header","","Same as `add_header` but allows value to be formatted directly into the buffer",8,{"inputs":[{"name":"self"},{"name":"str"},{"name":"d"}],"output":{"name":"result"}}],[11,"add_length","","Add a content length to the message.",8,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"result"}}],[11,"add_chunked","","Sets the transfer encoding to chunked.",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"is_started","","Returns true if at least `status()` method has been called",8,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"done_headers","","Closes the HTTP header and returns `true` if entity body is expected.",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write_body","","Write a chunk of the message body.",8,null],[11,"is_complete","","Returns true if `done()` method is already called and everything was okay.",8,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"done","","Writes needed finalization data into the buffer and asserts that response is in the appropriate state for that.",8,{"inputs":[{"name":"self"}],"output":{"name":"encoderdone"}}],[11,"raw_body","","Returns a raw body for zero-copy writing techniques",8,{"inputs":[{"name":"self"}],"output":{"name":"futurerawbody"}}],[11,"flush","","Flush the data to underlying socket",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bytes_buffered","","Returns bytes currently lying in the buffer",8,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"done","","Returns `EncoderDone` object that might be passed back to the HTTP protocol",7,{"inputs":[{"name":"self"}],"output":{"name":"encoderdone"}}],[11,"write","","",8,null],[11,"flush","","",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"shutdown","","",8,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"write","","",7,null],[11,"flush","","",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"shutdown","","",7,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"poll","","",9,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"method","","Returns a HTTP method",10,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"request_target","","Request-target (the middle part of the first line of request)",10,{"inputs":[{"name":"self"}],"output":{"name":"requesttarget"}}],[11,"raw_request_target","","Returns a raw request target as string",10,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"path","","Returns path portion of request uri",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"host","","Return host of a request",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"has_conflicting_host","","Returns true if `Host` header conflicts with host in request-uri",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"version","","Version of HTTP request",10,{"inputs":[{"name":"self"}],"output":{"name":"version"}}],[11,"headers","","Iterator over the headers of HTTP request",10,{"inputs":[{"name":"self"}],"output":{"name":"headeriter"}}],[11,"all_headers","","All headers of HTTP request",10,null],[11,"connection_close","","Return `true` if `Connection: close` header exists",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"connection_header","","Returns the value of the `Connection` header (all of them, if multiple)",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"has_body","","Returns true if there was transfer-encoding or content-length != 0",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"body_length","","Returns size of the request body if either `Content-Length` is set or it is safe to assume that request body is zero-length",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"get_websocket_upgrade","","Check if connection is a websocket and return hanshake info",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"next","","",11,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"buffered_upfront","","Download whole message body (request or response) into the memory before starting response",12,{"inputs":[{"name":"usize"}],"output":{"name":"recvmode"}}],[11,"progressive","","Fetch data chunk-by-chunk.",12,{"inputs":[{"name":"usize"}],"output":{"name":"recvmode"}}],[11,"hijack","","Don't read request body and hijack connection after response headers are sent. Useful for connection upgrades, including websockets and for CONNECT method.",12,{"inputs":[],"output":{"name":"recvmode"}}],[11,"body_read_timeout","","Change timeout for reading the whole request body to this value instead of configured default",12,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"recvmode"}}],[0,"buffered","","Higher-level interface for serving fully buffered requests",null,null],[3,"Request","tk_http::server::buffered","Buffered request struct",null,null],[3,"BufferedDispatcher","","A dispatcher that allows to process request and return response using a one single function",null,null],[3,"BufferedCodec","","A codec counterpart of the BufferedDispatcher, might be used with your own dispatcher too",null,null],[3,"WebsocketFactory","","A helper to create a simple websocket (and HTTP) service",null,null],[3,"WebsocketService","","An instance of websocket factory, created by WebsocketFactory itself",null,null],[8,"NewService","","A trait that you must implement to reply on requests, usually a function",null,null],[16,"Future","","Future returned by the service (an actual function serving request)",13,null],[16,"Instance","","Instance of the service, created for each request",13,null],[10,"new","","Constructor of the instance of the service, created for each request",13,null],[8,"Service","","An instance of a NewService for a single request, usually just a function",null,null],[16,"Future","","A future returned by `call()`",14,null],[16,"WebsocketFuture","","A future returned by `start_websocket`, it's spawned on the main loop hence needed to be static.",14,null],[10,"call","","A method which is called when request arrives, including the websocket negotiation request.",14,null],[10,"start_websocket","","A method which is called when websocket connection established",14,null],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",16,null],[11,"call","","",17,{"inputs":[{"name":"self"},{"name":"request"},{"name":"encoder"}],"output":{"name":"t"}}],[11,"start_websocket","","",17,{"inputs":[{"name":"self"},{"name":"writeframed"},{"name":"readframed"}],"output":{"name":"u"}}],[11,"peer_addr","","Returns peer address that initiated HTTP connection",15,{"inputs":[{"name":"self"}],"output":{"name":"socketaddr"}}],[11,"method","","Returns method of a request",15,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"path","","Returns path of a request",15,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"host","","Returns the host header of a request",15,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"version","","Returns HTTP version used in request",15,{"inputs":[{"name":"self"}],"output":{"name":"version"}}],[11,"headers","","Returns request headers",15,null],[11,"body","","Returns request body",15,null],[11,"websocket_handshake","","Returns websocket handshake if exists",15,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create an instance of bufferd dispatcher",18,{"inputs":[{"name":"socketaddr"},{"name":"handle"},{"name":"n"}],"output":{"name":"buffereddispatcher"}}],[11,"max_request_length","","Sets max request length",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"new_with_websockets","","Creates a dispatcher with two functions: one serving http requests and websockets.",18,{"inputs":[{"name":"socketaddr"},{"name":"handle"},{"name":"h"},{"name":"i"}],"output":{"name":"buffereddispatcher"}}],[11,"headers_received","","",18,{"inputs":[{"name":"self"},{"name":"head"}],"output":{"name":"result"}}],[11,"recv_mode","","",19,{"inputs":[{"name":"self"}],"output":{"name":"recvmode"}}],[11,"data_received","","",19,null],[11,"start_response","","",19,null],[11,"hijack","","",19,{"inputs":[{"name":"self"},{"name":"writebuf"},{"name":"readbuf"}],"output":null}],[8,"Codec","tk_http::server","The type represents a consumer of a single request and yields a writer of a response (the latter is a `ResponseFuture`",null,null],[16,"ResponseFuture","","This is a future returned by `start_response`",20,null],[10,"recv_mode","","Return a mode which will be used to receive request body",20,{"inputs":[{"name":"self"}],"output":{"name":"recvmode"}}],[10,"data_received","","Chunk of the response body received",20,null],[10,"start_response","","Start writing a response",20,null],[11,"hijack","","Called after future retunrted by `start_response` done if recv mode is `Hijack`",20,{"inputs":[{"name":"self"},{"name":"writebuf"},{"name":"readbuf"}],"output":null}],[8,"Dispatcher","","This is a low-level interface to the http server",null,null],[16,"Codec","","The codec type  for this dispatcher",21,null],[10,"headers_received","","Received headers of a request",21,{"inputs":[{"name":"self"},{"name":"head"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"config"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"recvmode"}}],[0,"client","tk_http","The HTTP/1.x client protocol implementation",null,null],[3,"Error","tk_http::client","HTTP client error",null,null],[3,"Encoder","","This a request writer that you receive in `Codec`",null,null],[3,"EncoderDone","","This structure returned from `Encoder::done` and works as a continuation that should be returned from the future that writes request.",null,null],[3,"Proto","","A low-level HTTP/1.x client protocol handler",null,null],[3,"Config","","Fine-grained configuration of the HTTP connection",null,null],[3,"Head","","A borrowed structure that represents response headers",null,null],[3,"RecvMode","","This type is returned from `headers_received` handler of either client client or server protocol handler",null,null],[11,"new","","Create a config with defaults",22,{"inputs":[],"output":{"name":"config"}}],[11,"inflight_request_limit","","A number of inflight requests until we start returning `NotReady` from `start_send`",22,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"inflight_request_prealoc","","Size of the queue that is preallocated for holding requests",22,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"keep_alive_timeout","","Keep-alive timeout",22,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"safe_pipeline_timeout","","Maximum time peer doesn't answer request before we consider this connection can't be used for pipelining more requests.",22,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"max_request_timeout","","Absolute maximum time of whole request can work",22,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"done","","Create a Arc'd config clone to pass to the constructor",22,{"inputs":[{"name":"self"}],"output":{"name":"arc"}}],[11,"request_line","","Write request line.",23,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"version"}],"output":null}],[11,"add_header","","Add a header to the message.",23,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"format_header","","Same as `add_header` but allows value to be formatted directly into the buffer",23,{"inputs":[{"name":"self"},{"name":"str"},{"name":"d"}],"output":{"name":"result"}}],[11,"add_length","","Add a content length to the message.",23,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"result"}}],[11,"add_chunked","","Sets the transfer encoding to chunked.",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"done_headers","","Closes the HTTP header",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write_body","","Write a chunk of body",23,null],[11,"done","","Finish writing request and return `EncoderDone` which can be moved to",23,{"inputs":[{"name":"self"}],"output":{"name":"encoderdone"}}],[11,"write","","",23,null],[11,"flush","","",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",24,{"inputs":[{"name":"errorenum"}],"output":{"name":"self"}}],[11,"description","","",24,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",24,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"custom","","Create an error instance wrapping custom error",24,{"inputs":[{"name":"e"}],"output":{"name":"error"}}],[11,"status","","Returns status if it is one of the supported statuses otherwise None",25,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"raw_status","","Returns raw status code and reason as received even",25,null],[11,"headers","","Iterator over the headers of HTTP request",25,{"inputs":[{"name":"self"}],"output":{"name":"headeriter"}}],[11,"all_headers","","All headers of HTTP request",25,null],[11,"new","","Create a new protocol implementation from a TCP connection and a config",26,{"inputs":[{"name":"s"},{"name":"handle"},{"name":"arc"}],"output":{"name":"proto"}}],[11,"connect_tcp","","A convenience method to establish connection and create a protocol instance",26,{"inputs":[{"name":"socketaddr"},{"name":"arc"},{"name":"handle"}],"output":{"name":"box"}}],[11,"start_send","","",26,null],[11,"poll_complete","","",26,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"buffered","","Download whole message body (request or response) into the memory.",27,{"inputs":[{"name":"usize"}],"output":{"name":"recvmode"}}],[11,"progressive","","Fetch data chunk-by-chunk.",27,{"inputs":[{"name":"usize"}],"output":{"name":"recvmode"}}],[0,"buffered","","Simple to use wrappers for dealing with fully buffered requests",null,null],[3,"Buffered","tk_http::client::buffered","Fully buffered (in-memory) writing request and reading response",null,null],[3,"Response","","A buffered response holds contains a body as contiguous chunk of data",null,null],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"status","","Get response status",28,{"inputs":[{"name":"self"}],"output":{"name":"status"}}],[11,"headers","","Get response headers",28,null],[11,"body","","Get response body",28,null],[11,"start_write","","",29,null],[11,"headers_received","","",29,{"inputs":[{"name":"self"},{"name":"head"}],"output":{"name":"result"}}],[11,"data_received","","",29,null],[11,"get","","Fetch data from url using GET method, fully buffered",29,null],[11,"max_response_length","","Set max response length for this buffered reader",29,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[8,"Client","tk_http::client","A marker trait that applies to a Sink that is essentially a HTTP client",null,null],[10,"fetch_url","","Simple fetch helper",30,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[8,"Codec","","This is a low-level interface to the http client",null,null],[16,"Future","","Future that `start_write()` returns",31,null],[10,"start_write","","Start writing a request",31,null],[10,"headers_received","","Received headers of a response",31,{"inputs":[{"name":"self"},{"name":"head"}],"output":{"name":"result"}}],[10,"data_received","","Chunk of the response body received",31,null],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"config"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"recvmode"}}],[0,"websocket","tk_http","Websocket support stuff",null,null],[3,"ServerCodec","tk_http::websocket","Websocket codec for use with tk-bufstream in `Codec::hijack()`",null,null],[3,"ClientCodec","","Websocket codec for use with tk-bufstream",null,null],[3,"Loop","","This is a helper for running websockets",null,null],[3,"Error","","Websocket Error works both for client and server connections",null,null],[3,"Accept","","The `Sec-WebSocket-Accept` header value",null,null],[3,"Key","","The `Sec-WebSocket-Key` header value",null,null],[3,"Config","","Configuration of a `websocket::Loop` object (a server-side websocket connection).",null,null],[4,"Packet","","A websocket packet",null,null],[13,"Ping","","Ping packet (with data)",32,null],[13,"Pong","","Pong packet (with data)",32,null],[13,"Text","","Text (utf-8) messsage",32,null],[13,"Binary","","Binary message",32,null],[13,"Close","","Close message",32,null],[4,"Frame","","A borrowed frame of websocket data",null,null],[13,"Ping","","Ping mesage",33,null],[13,"Pong","","Pong mesage",33,null],[13,"Text","","Text (utf-8) message",33,null],[13,"Binary","","Binary message",33,null],[13,"Close","","Close message",33,null],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"packet"}}],[11,"encode","","",34,{"inputs":[{"name":"self"},{"name":"packet"},{"name":"buf"}],"output":null}],[11,"decode","","",34,{"inputs":[{"name":"self"},{"name":"buf"}],"output":{"name":"result"}}],[11,"encode","","",35,{"inputs":[{"name":"self"},{"name":"packet"},{"name":"buf"}],"output":null}],[11,"decode","","",35,{"inputs":[{"name":"self"},{"name":"buf"}],"output":{"name":"result"}}],[11,"new","","Create a config with defaults",36,{"inputs":[],"output":{"name":"config"}}],[11,"ping_interval","","Set ping interval",36,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"inactivity_timeout","","Set inactivity timeout",36,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"max_packet_size","","Maximum packet size",36,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"done","","Create a Arc'd config clone to pass to the constructor",36,{"inputs":[{"name":"self"}],"output":{"name":"arc"}}],[11,"server","","Create a new websocket Loop (server-side)",37,{"inputs":[{"name":"writeframed"},{"name":"readframed"},{"name":"t"},{"name":"d"},{"name":"arc"},{"name":"handle"}],"output":{"name":"loop"}}],[11,"client","","Create a new websocket Loop (client-side)",37,{"inputs":[{"name":"writeframed"},{"name":"readframed"},{"name":"t"},{"name":"d"},{"name":"arc"},{"name":"handle"}],"output":{"name":"loop"}}],[11,"closing","","A websocket loop that sends failure and waits for closing handshake",37,{"inputs":[{"name":"writeframed"},{"name":"readframed"},{"name":"u16"},{"name":"str"},{"name":"arc"},{"name":"handle"}],"output":{"name":"loop"}}],[11,"poll","","",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",38,{"inputs":[{"name":"errorenum"}],"output":{"name":"self"}}],[11,"description","","",38,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",38,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"custom","","Create an error instance wrapping custom error",38,{"inputs":[{"name":"e"}],"output":{"name":"error"}}],[11,"new","","Create a new (random) key, eligible to use for client connection",39,{"inputs":[],"output":{"name":"key"}}],[11,"from_key_bytes","","Create an Accept header value from a key received in header",40,null],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"frame"}}],[11,"eq","","",33,{"inputs":[{"name":"self"},{"name":"frame"}],"output":{"name":"bool"}}],[11,"ne","","",33,{"inputs":[{"name":"self"},{"name":"frame"}],"output":{"name":"bool"}}],[11,"into","","",33,{"inputs":[{"name":"self"}],"output":{"name":"packet"}}],[0,"client","","Websocket client implementation",null,null],[3,"Encoder","tk_http::websocket::client","This a request writer that you receive in `Codec`",null,null],[3,"EncoderDone","","This structure returned from `Encoder::done` and works as a continuation that should be returned from the future that writes request.",null,null],[3,"Head","","A borrowed structure that represents response headers",null,null],[3,"HandshakeProto","","A future that resolves to framed streams when websocket handshake is done",null,null],[3,"SimpleAuthorizer","","Default handshake handler, if you just want to get websocket connected",null,null],[8,"Authorizer","","Authorizer sends all the necessary headers and checks response headers to establish websocket connection",null,null],[16,"Result","","The type that may be returned from a `header_received`. It should encompass everything parsed from input headers.",41,null],[10,"write_headers","","Write request headers",41,{"inputs":[{"name":"self"},{"name":"encoder"}],"output":{"name":"encoderdone"}}],[10,"headers_received","","A handler of response headers",41,{"inputs":[{"name":"self"},{"name":"head"}],"output":{"name":"result"}}],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new authorizer that sends specified host and path",43,{"inputs":[{"name":"a"},{"name":"b"}],"output":{"name":"simpleauthorizer"}}],[11,"write_headers","","",43,{"inputs":[{"name":"self"},{"name":"encoder"}],"output":{"name":"encoderdone"}}],[11,"headers_received","","",43,{"inputs":[{"name":"self"},{"name":"head"}],"output":{"name":"result"}}],[11,"request_line","","Write request line.",44,{"inputs":[{"name":"self"},{"name":"str"}],"output":null}],[11,"add_header","","Add a header to the websocket authenticatin data",44,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"format_header","","Same as `add_header` but allows value to be formatted directly into the buffer",44,{"inputs":[{"name":"self"},{"name":"str"},{"name":"d"}],"output":{"name":"result"}}],[11,"done","","Finish writing headers and return `EncoderDone` which can be moved to",44,{"inputs":[{"name":"self"}],"output":{"name":"encoderdone"}}],[11,"new","","Create an instance of future from already connected socket",45,{"inputs":[{"name":"s"},{"name":"a"}],"output":{"name":"handshakeproto"}}],[11,"poll","","",45,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"status","","Returns status if it is one of the supported statuses otherwise None",42,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"raw_status","","Returns raw status code and reason as received even",42,null],[11,"all_headers","","All headers of HTTP request",42,null],[17,"GUID","tk_http::websocket","WebSocket GUID constant (provided by spec)",null,null],[8,"Dispatcher","","Dispatches messages received from websocket",null,null],[16,"Future","","Future returned from `frame()`",46,null],[10,"frame","","A frame received",46,null],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"config"}}],[11,"fmt","tk_http","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"status"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"status"}}],[11,"code","","Returns 3 digit numeric code",1,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"reason","","Returns title for the status code",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"response_has_body","","Returns true if sending body is expected for such status code",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"from","","Make Status from u16 if known code is passed.",1,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"version"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"version"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hijack","tk_http::server","Called after future retunrted by `start_response` done if recv mode is `Hijack`",20,{"inputs":[{"name":"self"},{"name":"writebuf"},{"name":"readbuf"}],"output":null}]],"paths":[[4,"Version"],[4,"Status"],[3,"WebsocketHandshake"],[4,"RequestTarget"],[3,"Config"],[3,"Error"],[3,"Proto"],[3,"RawBody"],[3,"Encoder"],[3,"FutureRawBody"],[3,"Head"],[3,"HeaderIter"],[3,"RecvMode"],[8,"NewService"],[8,"Service"],[3,"Request"],[3,"WebsocketFactory"],[3,"WebsocketService"],[3,"BufferedDispatcher"],[3,"BufferedCodec"],[8,"Codec"],[8,"Dispatcher"],[3,"Config"],[3,"Encoder"],[3,"Error"],[3,"Head"],[3,"Proto"],[3,"RecvMode"],[3,"Response"],[3,"Buffered"],[8,"Client"],[8,"Codec"],[4,"Packet"],[4,"Frame"],[3,"ServerCodec"],[3,"ClientCodec"],[3,"Config"],[3,"Loop"],[3,"Error"],[3,"Key"],[3,"Accept"],[8,"Authorizer"],[3,"Head"],[3,"SimpleAuthorizer"],[3,"Encoder"],[3,"HandshakeProto"],[8,"Dispatcher"]]};
initSearch(searchIndex);
